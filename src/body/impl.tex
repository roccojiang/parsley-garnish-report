\documentclass[../../main.tex]{subfiles}

\begin{document}

\ourchapter{Simplifying Parsers and Expressions}\label{sec:impl}
At this stage, the left-recursion factoring transformation leaves a lot to be desired in terms of output quality.
This \namecref{sec:impl} takes a step back from linting rules and focuses on ensuring how transformed terms can get pretty-printed in a human-readable form.
The following ideas are explored:
\begin{itemize}
  \item First, \cref{sec:simplify-parsers} discusses how parsers can be simplified via domain-specific optimisations based on parser laws.
  \item Afterwards, \cref{sec:simplify-exprs} discusses how expressions can be partially evaluated to some extent. This is achieved using another intermediate \textsc{ast}, this time based on the $\lambda$-calculus, which unlocks the idea of $\beta$-reduction and normalisation as tools to reduce the complexity of these terms.
\end{itemize}

% Parser: syntactic approach to optimisation/simplification, focusing on term rewriting
% Expr: semantic approach to optimisation/simplification, focusing on denotations

\subfile{impl/parser}
\subfile{impl/expr}

\section*{Summary}
This \namecref{sec:impl} introduced the idea of simplifying parsers and normalising expressions, by representing both as intermediate \textsc{ast}s to improve their static inspectability.
It also demonstrated how these processes are related to the optimisation techniques used in both \texttt{parsley} Scala and \texttt{parsley} Haskell.

With promising results applying these simplifications on the \scala{example} parser from last \namecref{sec:factor-leftrec}, the improved \scala{Parser} \textsc{ast} unlocks the potential for more powerful and interesting transformations utilising specialised domain knowledge of parser combinators.

\end{document}
